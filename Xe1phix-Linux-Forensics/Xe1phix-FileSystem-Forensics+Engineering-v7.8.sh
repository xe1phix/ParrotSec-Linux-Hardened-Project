





##-========================================================================-##
##   [+] et the superblock information for the problem filesystem:
##-========================================================================-##
dumpe2fs /dev/hda2 | grep superblock


##-========================================================================-##
##   [+] ets the interval between checks to 13 days.
##-========================================================================-##
tune2fs -i 13d /dev/hda1




##-========================================================================-##
##   [+] se hashed b-trees to speed up directory lookups:
##-========================================================================-##
tune2fs -O dir_index /dev/hda1


##-========================================================================-##
##   [+] 
##-========================================================================-##
tune2fs -O sparse_super /dev/hda1


##-========================================================================-##
##   [+] 
##-========================================================================-##
tune2fs -O metadata_csum /dev/sdb


##-========================================================================-##
##   [+] Check the Block size
##-========================================================================-##
tune2fs -l /dev/sdb | grep 'Block size'


##-========================================================================-##
##   [+] Check the Block size
##-========================================================================-##
getconf PAGE_SIZE



##-========================================================================-##
##   [+] Enable the encryption feature flag on the filesystem
##-========================================================================-##
tune2fs -O encrypt /dev/sdb



##-========================================================================-##
##   [+] Migrating an Ext3 filesystem to a Ext4 filesystem
##-========================================================================-##
tune2fs -O extents,uninit_bg,dir_index /dev/sdb


##-========================================================================-##
##   [+] Defrag the Ext4 filesystem
##-========================================================================-##
e4defrag -c -v /dev/sdb


##-========================================================================-##
##   [+] Add a journal to the filesystem
##-========================================================================-##
tune2fs -j /dev/sdb



##-========================================================================-##
##   [+] 
##-========================================================================-##
ls -l /dev/disk/by-uuid


##-========================================================================-##
##   [+] 
##-========================================================================-##
uuidgen


##-========================================================================-##
##   [+] 
##-========================================================================-##
tune2fs -U 79fb806d-4350-4b8c-8bc3-f3bb0c6b56f2 /dev/sdc1


##-========================================================================-##
##   [+] 
##-========================================================================-##
mount -U 79fb806d-4350-4b8c-8bc3-f3bb0c6b56f2 /mnt/clonedisk


umount /dev/sda1
tune2fs -O extents,uninit_bg,dir_index /dev/sda1
fsck -pf /dev/sda1
mount -t ext4 /dev/sda1


##-========================================================================-##
##   [+] Filesystem check - use badblocks during an fsck check
##-========================================================================-##
fsck -vcck /dev/sdb


##-========================================================================-##
##   [+] utput bad sectors to stdout
##-========================================================================-##
badblocks -wsv /dev/sdb


##-========================================================================-##
##   [+] ass badblock info to a file
##-========================================================================-##
badblocks wsv -o /mnt/$Drive/badblocks.txt /dev/sdb


##-========================================================================-##
##   [+] ecreate the filesystem with the badblock info
##-========================================================================-##
mkfs.ext4 -l /mnt/$Drive/badblocks.txt /dev/sdb


##-========================================================================-##
##   [+] heck disk for bad blocks before formating it.
##-========================================================================-##
mkfs.ext4 -c /dev/sdb



##-========================================================================-##
##   [+] esize an XFS filesystem on the fly:
##-========================================================================-##
xfs_growfs /filesystempath





##-========================================================================-##
##   [+] ist the files and directory names in a particular image:
##-========================================================================-##
fls hdaimage.dd -r -f ext3 -i raw



##-========================================================================-##
##   [+] rite files to a specified output directory:
##-========================================================================-##
foremost -t all -o /$Dir/ -i image.dd




##-========================================================================-##
##   [+] Pass in one of the backup superblocks as an option to fsck:
##-========================================================================-##
fsck -b 32768 /dev/hda2


##-========================================================================-##
##   [+] assing the backup superblock into mount explicitly:
##-========================================================================-##
mount sb=32768 /dev/hda2 /mnt

##-========================================================================-##
##   [+] 
dd if=/dev/hda of=/mnt/recovery/hdaimage.dd


##-========================================================================-##
##   [+] 
##-========================================================================-##
gddrescue -n /dev/hda /mnt/recovery/hdaimage.raw rescued.log


##-========================================================================-##
##   [+] rab most of the error-free areas quickly
##-========================================================================-##




##-========================================================================-##
##   [+] Use ddrescue, skipping the dodgy areas
##       grab most of the error-free areas quickly
##-========================================================================-##
gddrescue -n /dev/hda /mnt/recovery/hdaimage.raw rescued.log



##-========================================================================-##
##   [+] ount the image as a loopback device:
##-========================================================================-##
mount -o loop /mnt/recovery/hdaimage.dd /mnt/hdaimage



##-========================================================================-##
##   [?] -r 1 instead of -n to 
##-========================================================================-##


##-========================================================================-##
##   [+] et as much as possible of the bad patches
##-========================================================================-##



##-========================================================================-##
##   [+] Find out where the partitions are:
##       list the start and end cylinders of each partition 
##       and the units in which they’re measured.
##-========================================================================-##
fdisk -lu /mnt/recovery/hdaimage.dd



##-========================================================================-##
##   [+] rite the image back onto another disk:
##-========================================================================-##
dd if=/mnt/recovery/hdaimage.raw of=/dev/hdb


##-========================================================================-##
##   [+] et the superblock information
##-========================================================================-##
dumpe2fs /dev/hda2 | grep superblock


##-========================================================================-##
##   [+] Pass in one of the backup superblocks as an option to fsck:
##-========================================================================-##
fsck -b 32768 /dev/hda2

##-========================================================================-##
##   [+] assing the backup superblock into mount explicitly:
##-========================================================================-##
mount sb=32768 /dev/hda2 /mnt



##-========================================================================-##
##   [+] When the superblock of a partition is damaged, 
##       you can specify a different superblock to use:
##-========================================================================-##
debugfs -b 1024 -s 8193 /dev/hda1



##-========================================================================-##
##   [+] ee which filesystems are mounted by issuing the command:
##-========================================================================-##
cat /proc/mounts


##-========================================================================-##
##   [+] Find out what filesystems your current kernel supports:
##-========================================================================-##
cat /proc/filesystems



##-========================================================================-##
##   [+] Query the mount options:
##-========================================================================-##
tune2fs ‐l /dev/sdXY | grep "Default mount options:"


##-========================================================================-##
##   [+] 
##-========================================================================-##
tune2fs ‐o acl /dev/sd


##-========================================================================-##
##   [+] 
##-========================================================================-##
systool -b scsi


##-========================================================================-##
##   [+] 
##-========================================================================-##

lsscsi -s


##-========================================================================-##
##   [+] 
##-========================================================================-##

find /sys/devices/ -name scan


##-========================================================================-##
##   [+] 
##-========================================================================-##

ls -l $( find /sys/devices/ -name scan )


##-========================================================================-##
##   [+] 
##-========================================================================-##

find /sys -name sda



##-========================================================================-##
##   [+] 
##-========================================================================-##

ls -ldF $( find /sys -name sda )



##-========================================================================-##
##   [+] 
##-========================================================================-##

tree /sys/block/sda
tree /sys/class/block/sda
tree /sys/devices/pci0000:00/0000:00:11.0/ata1/host0/target0:0:0/0:0:0:0/block/sda/

##-========================================================================-##
##   [+] 
##-========================================================================-##

tree /sys/block

##-========================================================================-##
##   [+] 
##-========================================================================-##

tree -L 2 -F /sys/bus/pci*


##-========================================================================-##
##   [+] 
##-========================================================================-##
lsusb -v -s 004:018


##-========================================================================-##
##   [+] 
##-========================================================================-##

more /sys/class/net/p3p1/{carrier,duplex,speed}

##-========================================================================-##
##   [+] 
##-========================================================================-##

more /sys/class/net/[ep]*/statistics/[rt]x_bytes

##-========================================================================-##
##   [+] 
##-========================================================================-##

more /sys/class/net/[ep]**/mtu


##-========================================================================-##
##   [+] 
##-========================================================================-##

tree -F /dev/disk



##-========================================================================-##
##   [+] 
##-========================================================================-##

/dev/bus/usb/*







##-========================================================================-##
##   [+] ind the logical sector size:
##-========================================================================-##
cat /sys/block/sda/queue/logical_block_size

##-========================================================================-##
##   [+] ind the physical sector size:
##-========================================================================-##
cat /sys/block/sda/queue/physical_block_size

##-========================================================================-##
##   [+] ind the physical sector size:
##-========================================================================-##
blockdev --getpbsz /dev/sda

##-========================================================================-##
##   [+] ind the logical sector size:
##-========================================================================-##
blockdev --getss /dev/sda



##-========================================================================-##
##   [+] et a disk to read-only by setting a kernel flag
##-========================================================================-##
hdparm -r1 /dev/sdk


##-========================================================================-##
##   [+] 
##-========================================================================-##
blockdev --setro /dev/sdk


##-========================================================================-##
##   [+] 
##-========================================================================-##
mount -o ro







##-========================================================================-##
##   [+] pecify the 4096-byte sector size with the -b flag
##-========================================================================-##
mmls -b 4096 /dev/sde







##-========================================================================-##
##   [+] Create A Ext4 Filesystem, specifying a block size of 4096-byte blocks:
##-========================================================================-##
mkfs.ext4 -b 4096 -O metadata_csum /dev/sde1


##-========================================================================-##
##   [+] Create an XFS FileSystem, specifying a block size of 8192-byte blocks:
##-========================================================================-##
mkfs.xfs -b size=8192 /dev/sde1



##-========================================================================-##
##   [+] Create a Btrfs FileSystem, using a custom node size or tree block size:
##-========================================================================-##
mkfs.btrfs -n 65536 /dev/sde1









##-========================================================================-##
##   [+] XFS Fragmentation and Defragmentation
##-========================================================================-##
## ------------------------------------------------------------------------ ##
##       Measure the current level of fragmentation with xfs_db.
## ------------------------------------------------------------------------ ##
xfs_db -c frag -r /dev/sdb1



##-========================================================================-##
##   [+] Defragment XFS with xfs_fsr.
##-========================================================================-##
xfs_fsr /dev/sdb1




##-========================================================================-##
##   [+] 
##-========================================================================-##
xfs_repair -v /dev/sda3













##-========================================================================-##
##   [+] efragment a file system or individual files and directories.
##-========================================================================-##
btrfs filesystem defragment /home
btrfs filesystem defragment /usr/local/ISOs/*.iso



##-========================================================================-##
##   [+] 
##-========================================================================-##
cat /etc/fstab




##-========================================================================-##
##   [+] Create a journal for an ext2 filesystem is as follows:
##-========================================================================-##
tune2fs -j /dev/hda1


tune2fs -c 0 /dev/hda1
##-========================================================================-##
##   [+] et the number of mounts between checks to 0
##-========================================================================-##



##-========================================================================-##
##   [+] Create a journal of size 512MB:
##-========================================================================-##
tune2fs -j -J size=512 /dev/hda1


##-========================================================================-##
##   [+] Create a journal file on a different device 
##       (here, /dev/hdb2) with this:
##-========================================================================-##
mke2fs -O journal_dev /dev/hdb2


##-========================================================================-##
##   [+] se this external journal file:
##-========================================================================-##
tune2fs -j -J device=/dev/hdb2 /dev/hda1


##-========================================================================-##
##   [+] isplay journal messages
##-========================================================================-##

journalctl --list-boots | head



mkdir /var/log/journal
chgrp systemd-journal /var/log/journal
chmod 2775 /var/log/journal
systemctl restart systemd-journald.service
setfacl -Rnm g:wheel:rx,d:g:wheel:rx,g:adm:rx,d:g:adm:rx /var/log/journal/




## =========================================== ##
##   Enabling persistent logging In journald
## =========================================== ##

## To enable persistent logging, create /var/log/journal:

mkdir -p /var/log/journal
systemd-tmpfiles --create --prefix /var/log/journal

##-========================================================================-##
##   [?] systemd will make the journal files owned by the "systemd-journal" group and
##       add an ACL for read permissions for users In the "adm" group
##-========================================================================-##




##-========================================================================-##
##   [+] Boot with these kernel command line options:
##-========================================================================-##
systemd.log_level=debug systemd.log_target=kmsg log_buf_len=1M





##-========================================================================-##
##   [+] ount a file system with write barriers disabled 
##-========================================================================-##
barrier=0    ## Ext4, 
nobarrier    ## XFS and Btrfs



data=ordered            ## Data blocks are written to the file system first, then metadata.
data=writeback          ## journals the metadata, and then data.
data=journal            ## writes all data twice: first to the journal and then to the data and metadata blocks.




##-========================================================================-##
##   [+] 
##-========================================================================-##
tune2fs -O ^has_journal /dev/sde1





##-========================================================================-##
##   [+] 
##-========================================================================-##

ls -l /dev/sd*

##-========================================================================-##
##   [+] 
##-========================================================================-##

ls -l /dev/mapper/




##-========================================================================-##
##   [+] 
##-========================================================================-##
pvscan

##-========================================================================-##
##   [+] 
##-========================================================================-##
vgscan

##-========================================================================-##
##   [+] 
##-========================================================================-##
pvdisplay

##-========================================================================-##
##   [+] 
##-========================================================================-##
vgdisplay



##-========================================================================-##
##   [+] 
##-========================================================================-##
swapon -s




##-========================================================================-##
##   [+] Hex dump of a disk partition which is part of a logical volume
##-========================================================================-##

hexdump -C /dev/sdb2


##-========================================================================-##
##   [+] 
##-========================================================================-##
fdisk -l /dev/sda | grep /dev/sda



##-========================================================================-##
##   [+] 
##-========================================================================-##
grep vg_ /etc/fstab


##-========================================================================-##
##   [+] 
##-========================================================================-##
lvcreate -n music -L 100M myvg0





##-========================================================================-##
##   [+] ount a partition read-only
##-========================================================================-##
mount -t ext3 -o ro /dev/sdb1 /mnt/tmp


##-========================================================================-##
##   [+] emount /dev/sdb1 as read/write,
##-========================================================================-##
mount -t ext3 -o remount,rw /dev/sdb1












##-========================================================================-##
##   [+] 
##-========================================================================-##
mount -t debugfs none /sys/kernel/debug


##-========================================================================-##
##   [+] Detailed traces can be generated using ftrace:
##-========================================================================-##
echo 1 >/sys/kernel/debug/tracing/events/kvm/enable


##-========================================================================-##
##   [+] 
##-========================================================================-##
cat /sys/kernel/debug/tracing/trace_pipe





##-========================================================================-##
##   [+] unmount the guest file system using fusermount.
##-========================================================================-##

fusermount -u /tmp/guestmount/24764


##-========================================================================-##
##   [+] 
##-========================================================================-##
perf kvm --host --guest --guestkallsyms=/tmp/guest.kallsyms --guestmodules=/tmp/guest.modules record -a


##-========================================================================-##
##   [+] 
##-========================================================================-##
mkdir -p /tmp/guestmount
sshfs -o allow_other,direct_io guest:/ /tmp/guestmount/24764



##-========================================================================-##
##   [+] 
##-========================================================================-##

perf kvm --host --guest --guestmount=/tmp/guestmount




##-========================================================================-##
##   [+] Generate a report from a data file created by perf kvm record.
##-========================================================================-##


perf kvm --host --guestmount=/tmp/guestmount report


##-========================================================================-##
##   [+] Generate a report for the guest, use the --guest argument.
##-========================================================================-##

perf kvm --guest --guestmount=/tmp/guestmount report


##-========================================================================-##
##   [+] 
##-========================================================================-##

perf kvm --host --guestmount=/tmp/guestmount report -i /tmp/perf.data.kvm






## --------------------------------------------------------------------------------------- ##
##   [+] Loop  Device - A block device that maps its data blocks to 
##       the blocks of a regular file in a filesystem or to another block device.
## --------------------------------------------------------------------------------------- ##
##   [?] Unlike other block devices, who maps their data block to a physical device 
##       such as a hard disk, optical disk drive, etc../ 
## --------------------------------------------------------------------------------------- ##

##-========================================================================-##
##   [+] Mounting a disk image in loopback
##-========================================================================-##
mkdir /mnt/kali
mount -o loop,ro /$Dir/kali.iso /mnt/kali


##-========================================================================-##
##   [+] 
##-========================================================================-##
mount -t iso9660 -o ro,loop=/dev/loop0 /home/xe1phix/parrotsec.iso /cdrom






##-========================================================================-##
##   [+] Linux loop­back
##-========================================================================-##
mount ‐t iso9660 ‐o loop file.iso /mnt          ## Mount a CD image
mount ‐t ext3 ‐o loop file.img /mnt             ## Mount an image with ext3 fs





dd if=/dev/zero of=/usr/vdisk.img bs=1024k count=1024
mkfs.ext3 /usr/vdisk.img
mount ‐o loop /usr/vdisk.img /mnt
umount /mnt; rm /usr/vdisk.img



##-========================================================================-##
##   [+] Linux with losetup
##-========================================================================-##

##  [?] /dev/zero is much faster than urandom, 

##  [?] but less secure for encryption.


dd if=/dev/urandom of=/usr/vdisk.img bs=1024k count=1024
losetup /dev/loop0 /usr/vdisk.img


##-========================================================================-##
##   [+] Creates and associates /dev/loop0
##-========================================================================-##
mkfs.ext3 /dev/loop0
mount /dev/loop0 /mnt
losetup ‐a                      # Check used loops
umount /mnt
losetup ‐d /dev/loop0           ## Detach
rm /usr/vdisk.img



##-========================================================================-##
##   [+] 
##-========================================================================-##
mount ‐t tmpfs ‐osize=64m tmpfs /memdisk


##-========================================================================-##
##   [+] Create temporary home directory
##-========================================================================-##
mount -t tmpfs -o mode=700,uid=${GUEST_USER} none ${GUEST_HOME}







##-========================================================================-##
##   [+] Read and write a 1 GB file on partition ad4s3c (/home)
##-========================================================================-##
time dd if=/dev/ad4s3c of=/dev/null bs=1024k count=1000
time dd if=/dev/zero bs=1024k count=1000 of=/home/1Gb.file
hdparm ‐tT /dev/hda


















##-========================================================================-##
##   [+] Backup and restore
##-========================================================================-##
dd if=/dev/hda of=/dev/hdc                                          ## Copy disk to disk (same size)
dd if=/dev/sda7 of=/home/root.img bs=4096 conv=notrunc,noerror      ## Backup /
dd if=/home/root.img of=/dev/sda7 bs=4096 conv=notrunc,noerror      ## Restore /

dd bs=1M if=/dev/sda | gzip ‐c > sda.gz                             ## Zip the backup
gunzip ‐dc ad4s3e.gz | dd of=/dev/ad0s3e bs=1M                      ## Restore the zip

dd bs=1M if=/dev/sda | gzip | ssh eedcoba@fry 'dd of=sda.gz'  ## remote
gunzip ‐dc sda.gz | ssh eedcoba@host 'dd of=/dev/sda bs=1M'




##-========================================================================-##
##   [+] Check for bad blocks
##-========================================================================-##
dd if=/dev/hda of=/dev/null bs=1m

##-========================================================================-##
##   [+] Send to remote machine
##-========================================================================-##
dd bs=1k if=/dev/hda1 conv=sync,noerror,notrunc | gzip | ssh root@fry 'dd of=hda1.gz bs=1k'

##-========================================================================-##
##   [+] Store into an image
##-========================================================================-##
dd bs=1k if=/dev/hda1 conv=sync,noerror,notrunc of=hda1.img

##-========================================================================-##
##   [+] Mount an image
##-========================================================================-##
mount ‐o loop /hda1.img /mnt

##-========================================================================-##
##   [+] Copy to a new disk
##-========================================================================-##
rsync ‐ax /mnt/ /newdisk/





##-================================================================================-##
##  [+] MBR tricks
##-================================================================================-##
## -------------------------------------------------------------------------------- ##
##  [?] The MBR contains the boot loader and the partition table and is 512 bytes
##  [?] The first 446 are for the boot loader, 
##  [?] bytes 446 to 512 are for the partition table.
## -------------------------------------------------------------------------------- ##


## ---------------------------------------------------------------------------------------------------------- ##
    dd if=/dev/sda of=/mbr_sda.bak bs=512 count=1               ## Backup the full MBR
## ---------------------------------------------------------------------------------------------------------- ##
    dd if=/dev/zero of=/dev/sda bs=512 count=1                  ## Delete MBR and partition table
## ---------------------------------------------------------------------------------------------------------- ##
    dd if=/mbr_sda.bak of=/dev/sda bs=512 count=1               ## Restore the full MBR
## ---------------------------------------------------------------------------------------------------------- ##
    dd if=/mbr_sda.bak of=/dev/sda bs=446 count=1               ## Restore only the boot loader
## ---------------------------------------------------------------------------------------------------------- ##
    dd if=/mbr_sda.bak of=/dev/sda bs=1 count=64 skip=446       ## Restore partition table
## ---------------------------------------------------------------------------------------------------------- ##






##-========================================================================-##
##   [+] Write the image back onto another disk:
##-========================================================================-##
dd if=/mnt/recovery/hdaimage.raw of=/dev/hdb








##-========================================================================-##
##   [+] Count ext4 events for the entire system, for 10 seconds:
##-========================================================================-##
perf stat -e 'ext4:*' -a sleep 10




##-========================================================================-##
##   [+] Trace all block device (disk I/O) requests with stack traces, until Ctrl-C:
##-========================================================================-##
perf record -e block:block_rq_insert -ag

##-========================================================================-##
##   [+] Trace all block device issues and completions (has timestamps), until Ctrl-C:
##-========================================================================-##
perf record -e block:block_rq_issue -e block:block_rq_complete -a

##-========================================================================-##
##   [+] Trace all block completions, of size at least 100 Kbytes, until Ctrl-C:
##-========================================================================-##
perf record -e block:block_rq_complete --filter 'nr_sector > 200'

##-========================================================================-##
##   [+] Trace all block completions, synchronous writes only, until Ctrl-C:
##-========================================================================-##
perf record -e block:block_rq_complete --filter 'rwbs == "WS"'

##-========================================================================-##
##   [+] Trace all block completions, all types of writes, until Ctrl-C:
##-========================================================================-##
perf record -e block:block_rq_complete --filter 'rwbs ~ "*W*"'

##-========================================================================-##
##   [+] Trace all minor faults (RSS growth) with stack traces, until Ctrl-C
##-========================================================================-##








##-========================================================================-##
##   [+] Use mmls to examine NVME disks:
##-========================================================================-##
mmls /dev/nvme0n1


##-========================================================================-##
##   [+] Shows various information about NVMe namespace support:
##-========================================================================-##
nvme id-ctrl /dev/nvme1 -H



##-========================================================================-##
##   [+] Check the size of the namespace
##-========================================================================-##
nvme id-ns /dev/nvme0n1




##-========================================================================-##
##   [+] List the associated files and paths for attached devices:
##-========================================================================-##
udevadm info /dev/sdf



##-========================================================================-##
##   [+] Image a disk into a SquashFS forensic evidence container
##-========================================================================-##
sfsimage -i /dev/sde kingston.sfs


##-========================================================================-##
##   [+] Add additional evidence to a container using sfsimage
##-========================================================================-##
sfsimage -a photo.jpg kingston.sfs



##-========================================================================-##
##   [+] List the contents of a SquashFS forensic evidence container
sfsimage -l kingston.sfs


##-========================================================================-##
##   [+] The *.sfs file is mounted with the -m flag
##-========================================================================-##
sfsimage -m kingston.sfs

##-========================================================================-##
##   [+] 
##-========================================================================-##
mmls kingston.sfs.d/image.raw



##-========================================================================-##
##   [+] Unmount it with the -u flag:
##-========================================================================-##
sfsimage -u kingston.sfs.d





##-========================================================================-##
##   [+] 
##-========================================================================-##
time dcfldd if=/dev/sdc of=./ssd-image.raw







##-=============================================================-##
##   [+] View the storage interfaces, type (SATA, NVME, SCSI
##-=============================================================-##
lshw -class storage


lshw -businfo

lshw -businfo -class storage
lshw -businfo -class disk

##-=====================================================-##
##   [+] view the speed, interface, cache, 
##       and rotation about the attached disks:
##-=====================================================-##
hdparm -I /dev/sda


##-=================================================-##
##   [+] enumerates all the SCSI, IDE, RAID, ATA, SATA,  
##       SAS, and NVME mass storage controller devices on a system:
##-========================================================================-##
for i in 00 01 04 05 06 07 08; do lspci -d ::01$i; done



##-=================================================-##
##   [+] lists all SATA mass storage controller  
##       (class ID 01, subclass ID 06) devices:
##-========================================================================-##
lspci -d ::0106



##-=================================================-##
##   [+] enumerates all FireWire, USB, and Fibre  
##       Channel serial bus controllers:
##-========================================================================-##
for i in 00 03 04; do lspci -d ::0C$i; done



##-=================================================-##
##   [+] query for an attached storage device
## (SATA, USB, SAS, FireWire, ATA, SCSI, and Fibre Channel)
##-========================================================================-##
lsscsi -v



##-=================================================-##
##   [+] Query lsblk for useful technical details
## (device name, size, physical and logical sector size, 
## transport (USB, SATA, SAS, etc), SCSI address, and more:
##-========================================================================-##
lsblk -pd -o TRAN,NAME,SERIAL,VENDOR,MODEL,REV,WWN,SIZE,HCTL,SUBSYSTEMS,HCTL


##-=================================================-##
##   [+] Extract SMART Data with smartctl
##-========================================================================-##
smartctl -x /dev/sda




##-=================================================-##
##   [+] Visable copy-on-write for single files/directories do:
##-========================================================================-##
chattr +C /dir/file




##-=================================================-##
##   [+] Recover all known file types. 
##-========================================================================-##

foremost -t all -i /path/to/image -o outputdir




##-====================================================================-##
##   [+] Clone a partition from physical disk /dev/sda, partition 1,  
##       to physical disk /dev/sdb, partition 1 with e2image, run
##-========================================================================-##

e2image -ra -p /dev/sda1 /dev/sdb1




##-========================================================================-##
##   [+] Clone a faulty or dying drive, run ddrescue twice.  
##       First round, copy every block without read error  
##       and log the errors to rescue.log.
##-========================================================================-##
ddrescue -f -n /dev/sdX /dev/sdY rescue.log



##-=================================================-##
##   [+] Copy only the bad blocks and try 3 times  
##       to read from the source before giving up.
##-========================================================================-##
ddrescue -d -f -r3 /dev/sdX /dev/sdY rescue.log








Advanced Forensics Format (AFF)
Advanced Forensic Framework 4 (AFF4)
Expert Witness Compression Format (EWF)
Raw Image Format
Open Virtualization Format (OVF)
QCOW Image Format
Virtual Disk Image (VDI)
Virtual Hard Disk (VHD)
VMWare Virtual Disk Format (VMDK)



##-=================================================-##
##   [+] Imaging a device on a Unix-based system:
##-=================================================-##
ewfacquire /dev/sda


##-=================================================-##
##   [+] Converting a RAW into an EWF image
##-=================================================-##
ewfacquire myfile.raw


##-=================================================-##
##   [+] 
##-=================================================-##
ewfacquire -c best -m fixed -t myfile -S 1T -u [-q] myfile.raw


##-=================================================-##
##   [+] 
##-=================================================-##
cat split.raw.??? | ewfacquirestream
cat myfile.??? | ewfacquirestream  -c best -m fixed -t myfile -S 1T 


##-=================================================-##
##   [+] Converting an optical disc (split) RAW into an EWF image (libewf 20110109 or later)
ewfacquire -T optical.cue optical.iso


##-=================================================-##
##   [+] Converting an EWF into another EWF format or a (split) RAW image
ewfexport image.E01


##-=================================================-##
##   [+] Exporting files from a logical image (L01)
##-=================================================-##
ewfexport image.L01


##-=================================================-##
##   [+] FUSE mounting an EWF image (libewf 20110828 or later)
##-=================================================-##
ewfmount image.E01 mount_point


##-=================================================-##
##   [+] FUSE mounting a logical image (L01) (libewf 20111016 or later)
##-=================================================-##
ewfmount -f files image.L01 mount_point


##-=================================================-##
##   [+] Verify an single image with results to the screen
##-=================================================-##
ewfverify image.E01







## 
dd_rescue /dev/hda myfile.img



##-=================================================-##
##   [+] dd compression to an image file on the fly.
##-=================================================-##

dd_rescue /dev/sda1 - | bzip2 > /dir/file.img.bz2




##-=================================================-##
##   [+] Read ten Gigabytes from the source drive 
##       and write that to a file and the sha256 hash 
of the ten Gigabyte chunk. 
##-=================================================-##
dcfldd if=/dev/sda hash=sha256 hashwindow=10G sha256log=sha256.txt hashconv=after bs=512 conv=noerror,sync split=10G splitformat=aa of=driveimage.dd



##-=================================================-##
##   [+] ount a QCOW image:
##-=================================================-##
qcowmount image.qcow2 /mnt/qcowimage/


##-=================================================-##
##   [+] Pass "allow_root" to the fuse sub system using the qcowmount -X option:
##-=================================================-##
qcowmount -X allow_root image.qcow2 /mnt/qcowimage/



unmount /mnt/qcowimage/ using umount:
umount /mnt/qcowimage/


##-=================================================-##
##   [+] Or fusermount:
##-=================================================-##
fusermount -u /mnt/qcowimage/






##-=================================================-##
##   [+] reate a new image, read/write snapshot of the original image:
##-=================================================-##
qemu-img create -f qcow2 -b centos-cleaninstall.img snapshot.img


## determine an images backing file
##-=================================================-##
qemu-img info snapshot.img

##-=================================================================-##
##                  [+] Temporary snapshots
##-=================================================================-##
## ----------------------------------------------------------------- ##
##   [?] any changes made to the virtual machine while it is 
##       running are written to temporary files and thrown away 
##       when the virtual machine is turned off
## ----------------------------------------------------------------- ##
qemu -hda centos-cleaninstall.img -snapshot









##-==========================================================-##
##   [+] Mount an overlay use the following mount options:
##-=================================================-##

mount -t overlay overlay -o lowerdir=/lower,upperdir=/upper,workdir=/work /merged


##-==================================================================================-##
## ---------------------------------------------------------------------------------- ##
##   [?] The lower directory can actually be a list of directories separated by :, 
##       all changes in the merged directory are still reflected in upper.
## ---------------------------------------------------------------------------------- ##

mount -t overlay overlay -o lowerdir=/lower1:/lower2:/lower3,upperdir=/upper,workdir=/work /merged


##-========================================================================-##
##   [+] add an overlayfs entry to /etc/fstab use the following format:
##-=================================================-##

/etc/fstab

overlay /merged overlay noauto,x-systemd.automount,lowerdir=/lower,upperdir=/upper,workdir=/work 0 0



##-===========================-##
##   [+] Read-only overlay
##-=================================================-##

mount -t overlay overlay -o lowerdir=/lower1:/lower2 /merged


##-=======================-##
##   [+] OverlayFS
##-=======================-##
if modinfo -n overlay >/dev/null 2>&1; then
    mkdir ${GUEST_HOME}/upper ${GUEST_HOME}/work
    chown ${GUEST_USER}:${GUEST_USER} ${GUEST_HOME}/upper ${GUEST_HOME}/work

    mount -t overlay -o lowerdir=${dist_gs}/skel:${site_gs}/skel,upperdir=${GUEST_HOME}/upper,workdir=${GUEST_HOME}/work overlay ${GUEST_HOME} || {
    umount ${GUEST_HOME}
    rm -rf ${GUEST_HOME}






udisksctl status

udisksctl info --object-path $OBJECT | --block-device $DEVICE

udisksctl mount --object-path $OBJECT | --block-device $DEVICE --filesystem-type $TYPE --options $OPTIONS --no-user-interaction

udisksctl unmount --object-path $OBJECT | --block-device $DEVICE --force --no-user-interaction

udisksctl unlock --object-path $OBJECT | --block-device $DEVICE --no-user-interaction --key-file $PATH

udisksctl lock --object-path $OBJECT | --block-device $DEVICE --no-user-interaction

udisksctl loop-setup --file $PATH --read-only --offset $OFFSET --size $SIZE --no-user-interaction

udisksctl loop-delete --object-path $OBJECT | --block-device $DEVICE --no-user-interaction

udisksctl power-off --object-path $OBJECT | --block-device $DEVICE --no-user-interaction

udisksctl smart-simulate --file $PATH --object-path $OBJECT | --block-device $DEVICE --no-user-interaction

udisksctl monitor

udisksctl dump



udisksctl mount --block-device /dev/sdb1 --filesystem-type btrfs


udisksctl info --block-device /dev/sdb


##-=================================================-##
##   [+] Show information about my DvD Drive:
##-=================================================-##
udisksctl info --drive hp_______DVDRAM_GU90N_M5NE3AH0028


udisksctl info --object-path block_devices/pktcdvd0




udisksctl loop-setup --file $PATH --read-only --offset $OFFSET --size $SIZE] --no-user-interaction






udisksctl loop-setup -r -f $Loop.iso


udisks --inhibit-all-polling







##-========================================================================-##
##   [+] set up ro/tmpfs-rw layered root fs
##-=================================================-##

root-ro-driver=[driver]

root-ro-driver=overlay
disable-root-ro=true



ROOT_TYPE=$(cat /proc/mounts | ${rootmnt}/bin/grep ${ROOT} | ${rootmnt}/usr/bin/cut -d' ' -f3)
ROOT_OPTIONS=$(cat /proc/mounts | ${rootmnt}/bin/grep ${ROOT} | ${rootmnt}/usr/bin/cut -d' ' -f4)
cat <<EOF >${rootmnt}/etc/fstab

##-========================================================================-##
##   [+] overlay

##-=================================================-##
mount -t overlay -o lowerdir=${ROOT_RO},upperdir=${ROOT_RW_UPPER},workdir=${ROOT_RW_WORK} overlay ${rootmnt}


##-========================================================================-##
##   [+] aufs
##-=================================================-##

munt -t aufs -o dirs=${ROOT_RW}:${ROOT_RO}=ro aufs-root ${rootmnt}



##-========================================================================-##
##   [+] mMount a tempfs using the device name tmpfs-root at ${ROOT_RW}
##-=================================================-##
mount -t tmpfs tmpfs-root ${ROOT_RW}


##-========================================================================-##
##   [+] Root is mounted on ${rootmnt}, move it to ${ROOT_RO}.
##-========================================================================-##
mount -o move ${rootmnt} ${ROOT_RO}






##-========================================================================-##
##   [+] Write access can be enabled using:
mount -o remount,rw ${ROOT_RW}



##-========================================================================-##
##   [+] re-mounting it read-only is done using:
mount -o remount,ro ${ROOT_RO}



##-========================================================================-##
##   [+] Remove root entry and swap from fstab
cat ${rootmnt}${ROOT_RO}/etc/fstab | ${rootmnt}/bin/grep -v ' / ' | ${rootmnt}/bin/grep -v swap >>${rootmnt}/etc/fstab



